[
  {
    "name": "Sistemas Operativos",
    "url": "operating-systems",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Simulación y Computación Numérica",
    "url": "simulation-numerical-computing",
    "syllabus": [
      {
        "name": "Teorema de Bolzano",
        "url": "bolzano-theorem",
        "examples": [
          {
            "id": 1,
            "title": "Verificación del Teorema de Bolzano en Rust",
            "text": "Implementar una función que verifique el Teorema de Bolzano para diferentes funciones y intervalos.<br><br>● Verificar la continuidad y cambio de signo<br>● Encontrar intervalos donde se cumple el teorema<br>● Visualizar gráficamente los resultados",
            "code": "// Teorema de Bolzano en Rust\n\n// Funciones de prueba\nfn funcion_1(x: f64) -> f64 {\n    x * x - 2.0  // f(x) = x² - 2\n}\n\nfn funcion_2(x: f64) -> f64 {\n    x * x * x - x - 2.0  // f(x) = x³ - x - 2\n}\n\nfn funcion_3(x: f64) -> f64 {\n    f64::sin(x) - x / 2.0  // f(x) = sin(x) - x/2\n}\n\nfn funcion_4(x: f64) -> f64 {\n    f64::exp(x) - 3.0 * x  // f(x) = e^x - 3x\n}\n\n// Verificar Teorema de Bolzano\nfn verificar_bolzano<F>(f: F, a: f64, b: f64) -> bool\nwhere\n    F: Fn(f64) -> f64,\n{\n    let fa = f(a);\n    let fb = f(b);\n    \n    // Teorema de Bolzano: f(a) × f(b) < 0\n    fa * fb < 0.0\n}\n\n// Buscar intervalo donde se cumple Bolzano (método de exploración)\nfn buscar_intervalo_bolzano<F>(f: F, inicio: f64, fin: f64, paso: f64) -> Option<(f64, f64)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut x = inicio;\n    \n    while x < fin {\n        let a = x;\n        let b = x + paso;\n        \n        if verificar_bolzano(&f, a, b) {\n            return Some((a, b));\n        }\n        \n        x += paso;\n    }\n    \n    None\n}\n\n// Verificar continuidad numérica (simple check)\nfn es_continua<F>(f: F, a: f64, b: f64, num_puntos: usize) -> bool\nwhere\n    F: Fn(f64) -> f64,\n{\n    let paso = (b - a) / (num_puntos as f64);\n    let mut x = a;\n    \n    // Verificar que no hay discontinuidades obvias (valores infinitos o NaN)\n    for _ in 0..num_puntos {\n        let valor = f(x);\n        if valor.is_infinite() || valor.is_nan() {\n            return false;\n        }\n        x += paso;\n    }\n    \n    true\n}\n\nfn main() {\n    println!(\"=== Verificación del Teorema de Bolzano ===\\n\");\n    \n    // Prueba 1: f(x) = x² - 2 en [1, 2]\n    let a1 = 1.0;\n    let b1 = 2.0;\n    let continua1 = es_continua(funcion_1, a1, b1, 100);\n    let bolzano1 = verificar_bolzano(funcion_1, a1, b1);\n    \n    println!(\"Función 1: f(x) = x² - 2\");\n    println!(\"Intervalo: [{}, {}]\", a1, b1);\n    println!(\"f({}) = {:.4}\", a1, funcion_1(a1));\n    println!(\"f({}) = {:.4}\", b1, funcion_1(b1));\n    println!(\"Continua: {}\", continua1);\n    println!(\"Cumple Bolzano: {}\", bolzano1);\n    println!(\"Teorema aplicable: {}\", continua1 && bolzano1);\n    \n    if continua1 && bolzano1 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a1, b1);\n    }\n    println!();\n    \n    // Prueba 2: f(x) = x³ - x - 2\n    let a2 = 1.0;\n    let b2 = 2.0;\n    let continua2 = es_continua(funcion_2, a2, b2, 100);\n    let bolzano2 = verificar_bolzano(funcion_2, a2, b2);\n    \n    println!(\"Función 2: f(x) = x³ - x - 2\");\n    println!(\"Intervalo: [{}, {}]\", a2, b2);\n    println!(\"f({}) = {:.4}\", a2, funcion_2(a2));\n    println!(\"f({}) = {:.4}\", b2, funcion_2(b2));\n    println!(\"Continua: {}\", continua2);\n    println!(\"Cumple Bolzano: {}\", bolzano2);\n    println!(\"Teorema aplicable: {}\", continua2 && bolzano2);\n    \n    if continua2 && bolzano2 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a2, b2);\n    }\n    println!();\n    \n    // Prueba 3: f(x) = sin(x) - x/2\n    let a3 = 1.0;\n    let b3 = 3.0;\n    let continua3 = es_continua(funcion_3, a3, b3, 100);\n    let bolzano3 = verificar_bolzano(funcion_3, a3, b3);\n    \n    println!(\"Función 3: f(x) = sin(x) - x/2\");\n    println!(\"Intervalo: [{}, {}]\", a3, b3);\n    println!(\"f({}) = {:.4}\", a3, funcion_3(a3));\n    println!(\"f({}) = {:.4}\", b3, funcion_3(b3));\n    println!(\"Continua: {}\", continua3);\n    println!(\"Cumple Bolzano: {}\", bolzano3);\n    println!(\"Teorema aplicable: {}\", continua3 && bolzano3);\n    \n    if continua3 && bolzano3 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a3, b3);\n    }\n    println!();\n    \n    // Prueba 4: Buscar intervalo automáticamente\n    println!(\"=== Búsqueda Automática de Intervalos ===\");\n    \n    match buscar_intervalo_bolzano(funcion_1, -5.0, 5.0, 0.5) {\n        Some((a, b)) => {\n            println!(\"Función 1: Intervalo encontrado [{}, {}]\", a, b);\n            println!(\"f({}) = {:.4}, f({}) = {:.4}\", a, funcion_1(a), b, funcion_1(b));\n        },\n        None => println!(\"Función 1: No se encontró intervalo con Bolzano en [-5, 5]\"),\n    }\n    \n    match buscar_intervalo_bolzano(funcion_4, -2.0, 2.0, 0.5) {\n        Some((a, b)) => {\n            println!(\"Función 4: Intervalo encontrado [{}, {}]\", a, b);\n            println!(\"f({}) = {:.4}, f({}) = {:.4}\", a, funcion_4(a), b, funcion_4(b));\n        },\n        None => println!(\"Función 4: No se encontró intervalo con Bolzano en [-2, 2]\"),\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de Bisección",
        "url": "bisection-method",
        "examples": [
          {
            "id": 1,
            "title": "Implementación del Método de Bisección en Rust",
            "text": "Implementar el método de bisección para encontrar la raíz de f(x) = x² - 2 en el intervalo [1, 2].<br><br>● Definir la función objetivo<br>● Implementar el algoritmo de bisección<br>● Probar con diferentes tolerancias",
            "code": "// Método de Bisección en Rust\n\n// Función objetivo: f(x) = x² - 2\nfn funcion_objetivo(x: f64) -> f64 {\n    x * x - 2.0\n}\n\n// Método de bisección\nfn biseccion<F>(f: F, mut a: f64, mut b: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut fa = f(a);\n    let mut fb = f(b);\n    \n    // Verificar condición de Bolzano\n    if fa * fb >= 0.0 {\n        println!(\"No se cumple la condición f(a) × f(b) < 0\");\n        return None;\n    }\n    \n    for iter in 0..max_iter {\n        let c = (a + b) / 2.0;\n        let fc = f(c);\n        \n        // Verificar convergencia\n        if fc.abs() < tolerancia || (b - a) / 2.0 < tolerancia {\n            return Some((c, iter + 1));\n        }\n        \n        // Actualizar intervalo\n        if fa * fc < 0.0 {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n\nfn main() {\n    let a = 1.0;\n    let b = 2.0;\n    let tolerancia = 1e-6;\n    let max_iter = 100;\n    \n    println!(\"Buscando raíz de f(x) = x² - 2 en [{}, {}]\", a, b);\n    println!(\"Tolerancia: {}\", tolerancia);\n    \n    match biseccion(funcion_objetivo, a, b, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n    \n    // Prueba con diferentes tolerancias\n    println!(\"\\n=== Pruebas con diferentes tolerancias ===\");\n    let tolerancias = [1e-3, 1e-6, 1e-9, 1e-12];\n    \n    for &tol in &tolerancias {\n        if let Some((raiz, iter)) = biseccion(funcion_objetivo, a, b, tol, max_iter) {\n            println!(\"Tol: {:.0e} → Raíz: {:.10} ({} iter)\", tol, raiz, iter);\n        }\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Interpolación",
        "url": "interpolation",
        "examples": [
          {
            "id": 1,
            "title": "Interpolación de Lagrange en Rust",
            "text": "Implementar el polinomio de interpolación de Lagrange para un conjunto de puntos dados.<br><br>● Calcular los polinomios base L_i(x)<br>● Evaluar el polinomio interpolador P(x)<br>● Comparar con el valor real de la función original",
            "code": "// Interpolación de Lagrange en Rust\n\n// Función para calcular el polinomio de Lagrange\nfn lagrange_interpolation(x_points: &[f64], y_points: &[f64], x: f64) -> f64 {\n    let n = x_points.len();\n    let mut result = 0.0;\n\n    for i in 0..n {\n        let mut term = y_points[i];\n        for j in 0..n {\n            if i != j {\n                term *= (x - x_points[j]) / (x_points[i] - x_points[j]);\n            }\n        }\n        result += term;\n    }\n\n    result\n}\n\nfn main() {\n    // Puntos conocidos\n    let x_known = [1.0, 2.0, 3.0];\n    let y_known = [1.0, 4.0, 9.0]; // f(x) = x^2\n\n    let x_to_eval = 2.5;\n    let result = lagrange_interpolation(&x_known, &y_known, x_to_eval);\n    let actual = x_to_eval.powi(2);\n\n    println!(\"P({}) = {}\", x_to_eval, result);\n    println!(\"f({}) = {}\", x_to_eval, actual);\n    println!(\"Error de interpolación = {}\", (result - actual).abs());\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Aproximación por Mínimos Cuadrados",
        "url": "least-squares",
        "examples": [
          {
            "id": 1,
            "title": "Regresión Lineal Simple en Rust",
            "text": "Calcular la recta de mínimos cuadrados para un conjunto de datos bivariados.<br><br>● Calcular pendiente (m) e intercepto (b)<br>● Calcular el coeficiente de correlación (r)",
            "code": "// Regresión Lineal Simple en Rust\n\n// Función para calcular la regresión lineal\nfn linear_regression(x_vals: &[f64], y_vals: &[f64]) -> (f64, f64, f64) {\n    let n = x_vals.len() as f64;\n    let sum_x = x_vals.iter().sum::<f64>();\n    let sum_y = y_vals.iter().sum::<f64>();\n    let sum_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| x * y).sum();\n    let sum_x2: f64 = x_vals.iter().map(|x| x * x).sum();\n\n    let mean_x = sum_x / n;\n    let mean_y = sum_y / n;\n\n    let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);\n    let intercept = mean_y - slope * mean_x;\n\n    // Coeficiente de correlación\n    let ss_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| (x - mean_x) * (y - mean_y)).sum();\n    let ss_xx: f64 = x_vals.iter().map(|x| (x - mean_x).powi(2)).sum();\n    let ss_yy: f64 = y_vals.iter().map(|y| (y - mean_y).powi(2)).sum();\n    let correlation = ss_xy / (ss_xx * ss_yy).sqrt();\n\n    (slope, intercept, correlation)\n}\n\nfn main() {\n    let x_data = [1.0, 2.0, 3.0, 4.0, 5.0];\n    let y_data = [2.1, 3.9, 6.1, 7.9, 10.0];\n\n    let (slope, intercept, correlation) = linear_regression(&x_data, &y_data);\n\n    println!(\"Recta de regresión: y = {:.4}x + {:.4}\", slope, intercept);\n    println!(\"Coeficiente de correlación (r): {:.4}\", correlation);\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Sistemas de Ecuaciones Lineales y No Lineales",
        "url": "system-of-equations",
        "examples": [
          {
            "id": 1,
            "title": "Método de Jacobi en Rust",
            "text": "Implementar el método iterativo de Jacobi para resolver un sistema de ecuaciones lineales Ax = b.<br><br>● Verificar convergencia (diagonal dominante)<br>● Iterar hasta cumplir criterio de parada",
            "code": "// Método de Jacobi en Rust\n\n// Función para calcular la norma infinito de un vector\nfn norm_inf(v: &[f64]) -> f64 {\n    v.iter().map(|x| x.abs()).fold(0.0, |a, b| a.max(b))\n}\n\n// Función para clonar un vector\nfn clone_vec(v: &[f64]) -> Vec<f64> {\n    v.iter().cloned().collect()\n}\n\n// Método de Jacobi\nfn jacobi_method(\n    a: &Vec<Vec<f64>>,\n    b: &[f64],\n    mut x: Vec<f64>,\n    tolerance: f64,\n    max_iterations: usize,\n) -> Option<Vec<f64>> {\n    let n = b.len();\n    let mut x_new = vec![0.0; n];\n\n    for iteration in 0..max_iterations {\n        for i in 0..n {\n            let mut sum = 0.0;\n            for j in 0..n {\n                if i != j {\n                    sum += a[i][j] * x[j];\n                }\n            }\n            x_new[i] = (b[i] - sum) / a[i][i];\n        }\n\n        // Criterio de parada\n        let diff: Vec<f64> = x_new.iter().zip(x.iter()).map(|(a, b)| a - b).collect();\n        if norm_inf(&diff) < tolerance {\n            println!(\"Convergió en {} iteraciones.\", iteration + 1);\n            return Some(x_new);\n        }\n\n        x = clone_vec(&x_new);\n    }\n\n    println!(\"No se alcanzó la convergencia en {} iteraciones.\", max_iterations);\n    None\n}\n\nfn main() {\n    // Ejemplo de sistema\n    let a = vec!\n    [\n        vec![4.0, -1.0, 0.0],\n        vec![-1.0, 4.0, -1.0],\n        vec![0.0, -1.0, 4.0],\n    ];\n    let b = [12.0, 12.0, 12.0];\n    let x_initial = vec![0.0, 0.0, 0.0];\n    let tolerance = 1e-3;\n    let max_iter = 100;\n\n    match jacobi_method(&a, &b, x_initial, tolerance, max_iter) {\n        Some(solution) => println!(\"Solución x: {:?}\", solution),\n        None => println!(\"No se pudo resolver el sistema.\"),\n    }\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de Diferencias Finitas (MDF) para PVF",
        "url": "finite-difference-method",
        "examples": [
          {
            "id": 1,
            "title": "MDF para EDO: 4y'' - 2y' + y + x = 0",
            "text": "Resolver el PVF: 4y'' - 2y' + y + x = 0, con y(0)=1, y(20)=10, usando MDF.<br><br>● Discretizar el dominio [0, 20] con N nodos interiores<br>● Aproximar y'' y y' con diferencias centradas<br>● Construir el sistema lineal tridiagonal AY = b<br>● Resolver el sistema para obtener la solución numérica",
            "code": "// MDF para EDO: 4y'' - 2y' + y + x = 0\n// y(0) = 1, y(20) = 10\n\n// Función para resolver un sistema tridiagonal usando el algoritmo de Thomas\nfn thomas_algorithm(a: &[f64], b: &[f64], c: &[f64], d: &[f64]) -> Vec<f64> {\n    let n = d.len();\n    let mut a = a.to_vec(); // Subdiagonal\n    let mut b = b.to_vec(); // Diagonal principal\n    let mut c = c.to_vec(); // Superdiagonal\n    let mut d = d.to_vec(); // Vector RHS\n\n    // Eliminación hacia adelante\n    for i in 1..n {\n        let factor = a[i] / b[i-1];\n        b[i] -= factor * c[i-1];\n        d[i] -= factor * d[i-1];\n    }\n\n    // Sustitución hacia atrás\n    let mut y = vec![0.0; n];\n    y[n-1] = d[n-1] / b[n-1];\n    for i in (0..n-1).rev() {\n        y[i] = (d[i] - c[i] * y[i+1]) / b[i];\n    }\n\n    y\n}\n\nfn solve_bvp_mdf(n: usize, a_start: f64, b_end: f64, alpha: f64, beta: f64) -> (Vec<f64>, Vec<f64>) {\n    let h = (b_end - a_start) / ((n + 1) as f64);\n    let mut x_full = vec![0.0; n + 2];\n    for i in 0..n + 2 {\n        x_full[i] = a_start + (i as f64) * h;\n    }\n\n    // Coeficientes de la EDO reescrita como y'' = (1/2)y' - (1/4)y - (1/4)x\n    // p(x) = 1/2, q(x) = -1/4, r(x) = -1/4 * x\n    let p_val = 0.5;\n    let q_val = -0.25;\n\n    // Inicializar vectores para el sistema tridiagonal Ay = b\n    // a: subdiagonal, b: diagonal, c: superdiagonal\n    let mut a_vec = vec![0.0; n];\n    let mut b_vec = vec![0.0; n];\n    let mut c_vec = vec![0.0; n];\n    let mut d_vec = vec![0.0; n];\n\n    for i in 0..n {\n        let x_i = x_full[i + 1]; // x en el nodo interior i+1\n\n        // Coeficientes para y_{i+1}, y_i, y_{i-1}\n        c_vec[i] = 1.0 - (h / 2.0) * p_val; // Coeficiente de y_{i+1}\n        a_vec[i] = 1.0 + (h / 2.0) * p_val; // Coeficiente de y_{i-1}\n        b_vec[i] = -2.0 - h * h * q_val;    // Coeficiente de y_i\n\n        // Término independiente\n        d_vec[i] = h * h * (-0.25 * x_i); // h^2 * r(x_i)\n\n        // Aplicar condiciones de frontera en el RHS\n        if i == 0 {\n            d_vec[i] -= a_vec[i] * alpha; // a_1 depende de y_0 = alpha\n        }\n        if i == n - 1 {\n            d_vec[i] -= c_vec[i] * beta;  // c_n depende de y_{N+1} = beta\n        }\n    }\n\n    // Resolver el sistema tridiagonal Ay = b\n    let y_interior = thomas_algorithm(&a_vec, &b_vec, &c_vec, &d_vec);\n\n    // Construir la solución completa con fronteras\n    let mut y_full = vec![0.0; n + 2];\n    y_full[0] = alpha;\n    y_full[1..n+1].copy_from_slice(&y_interior);\n    y_full[n+1] = beta;\n\n    (x_full, y_full)\n}\n\nfn main() {\n    let a = 0.0;\n    let b = 20.0;\n    let alpha = 1.0;\n    let beta = 10.0;\n    let n = 3; // Número de nodos interiores, como en las imágenes\n\n    println!(\"Resolviendo el PVF: 4y'' - 2y' + y + x = 0, con y(0)={}, y(20)={}\", alpha, beta);\n    println!(\"N nodos interiores: {}\", n);\n\n    let (x_vals, y_vals) = solve_bvp_mdf(n, a, b, alpha, beta);\n\n    println!(\"\\nSolución (x_i, y_i): \");\n    for i in 0..x_vals.len() {\n        println!(\"x[{}] = {:.1}, y[{}] = {:.7}\", i, x_vals[i], i, y_vals[i]);\n    }\n    println!(\"\\n--- Comparación con resultados de la imagen (N=3) ---\");\n    println!(\"Resultados esperados (aproximados):\");\n    println!(\"x = [0.0, 5.0, 10.0, 15.0, 20.0]\");\n    println!(\"y = [1.0, -8.5355432, -11.104235, -15.591876, 10.0]\");\n    println!(\"\\nResultados calculados:\");\n    println!(\"y = {:?}\", y_vals);\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Ajuste Lineal",
        "url": "least-squares-linear",
        "examples": [
          {
            "id": 1,
            "title": "Regresión Lineal Simple en Rust",
            "text": "Implementar el método de mínimos cuadrados para ajustar una recta a un conjunto de datos.<br><br>● Calcular las sumas necesarias (Σx, Σy, Σx², Σxy)<br>● Resolver el sistema de ecuaciones normales<br>● Devolver la pendiente y el intercepto de la recta",
            "code": "// Regresión Lineal Simple en Rust\n\nfn linear_regression(x_vals: &[f64], y_vals: &[f64]) -> (f64, f64) {\n    let n = x_vals.len() as f64;\n    let sum_x = x_vals.iter().sum::<f64>();\n    let sum_y = y_vals.iter().sum::<f64>();\n    let sum_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| x * y).sum();\n    let sum_x2: f64 = x_vals.iter().map(|x| x * x).sum();\n\n    // Sistema de ecuaciones normales:\n    // (Σ1)*a0 + (Σx)*a1 = Σy\n    // (Σx)*a0 + (Σx²)*a1 = Σxy\n    // En forma matricial: A * [a0; a1] = b\n    \n    // Coeficiente de la matriz A\n    let a11 = n;\n    let a12 = sum_x;\n    let a21 = sum_x;\n    let a22 = sum_x2;\n    \n    // Vector b\n    let b1 = sum_y;\n    let b2 = sum_xy;\n    \n    // Resolver el sistema usando regla de Cramer (para 2x2)\n    let det_a = a11 * a22 - a12 * a21;\n    if det_a.abs() < 1e-10 {\n        panic!(\"El sistema no tiene solución única.\");\n    }\n    \n    let a0 = (b1 * a22 - b2 * a12) / det_a;\n    let a1 = (a11 * b2 - a21 * b1) / det_a;\n    \n    (a0, a1)\n}\n\nfn main() {\n    // Datos del ejemplo\n    let x_data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let y_data = [1.3, 3.5, 4.2, 5.0, 7.0, 8.8, 10.1, 12.5, 13.0, 15.6];\n\n    let (intercept, slope) = linear_regression(&x_data, &y_data);\n\n    println!(\"Recta de mejor ajuste: y = {:.4} + {:.4}x\", intercept, slope);\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Ajuste Cuadrático",
        "url": "least-squares-quadratic",
        "examples": [
          {
            "id": 1,
            "title": "Regresión Cuadrática en Rust",
            "text": "Implementar el método de mínimos cuadrados para ajustar una parábola a un conjunto de datos.<br><br>● Calcular las sumas necesarias (Σx, Σx², Σx³, Σx⁴, Σy, Σxy, Σx²y)<br>● Resolver el sistema de ecuaciones normales 3x3<br>● Devolver los coeficientes a0, a1, a2 de la parábola y = a0 + a1x + a2x²",
            "code": "// Regresión Cuadrática en Rust\n\n// Función para resolver un sistema 3x3 por eliminación gaussiana\nfn solve_3x3_system(a: [[f64; 3]; 3], b: [f64; 3]) -> [f64; 3] {\n    let mut a_aug = [\n        [a[0][0], a[0][1], a[0][2], b[0]],\n        [a[1][0], a[1][1], a[1][2], b[1]],\n        [a[2][0], a[2][1], a[2][2], b[2]]\n    ];\n    \n    // Eliminación hacia adelante\n    for i in 0..2 {\n        // Pivoteo (simplificado)\n        if a_aug[i][i].abs() < 1e-10 {\n            continue;\n        }\n        \n        for j in (i+1)..3 {\n            let factor = a_aug[j][i] / a_aug[i][i];\n            for k in i..4 {\n                a_aug[j][k] -= factor * a_aug[i][k];\n            }\n        }\n    }\n    \n    // Sustitución hacia atrás\n    let mut x = [0.0; 3];\n    x[2] = a_aug[2][3] / a_aug[2][2];\n    x[1] = (a_aug[1][3] - a_aug[1][2] * x[2]) / a_aug[1][1];\n    x[0] = (a_aug[0][3] - a_aug[0][1] * x[1] - a_aug[0][2] * x[2]) / a_aug[0][0];\n    \n    x\n}\n\nfn quadratic_regression(x_vals: &[f64], y_vals: &[f64]) -> (f64, f64, f64) {\n    let n = x_vals.len() as f64;\n    let sum_x = x_vals.iter().sum::<f64>();\n    let sum_y = y_vals.iter().sum::<f64>();\n    let sum_x2: f64 = x_vals.iter().map(|x| x * x).sum();\n    let sum_x3: f64 = x_vals.iter().map(|x| x * x * x).sum();\n    let sum_x4: f64 = x_vals.iter().map(|x| x * x * x * x).sum();\n    let sum_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| x * y).sum();\n    let sum_x2y: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| x * x * y).sum();\n\n    // Sistema de ecuaciones normales:\n    // [ Σ1   Σx   Σx² ] [a0]   [ Σy  ]\n    // [ Σx   Σx²  Σx³ ] [a1] = [ Σxy ]\n    // [ Σx²  Σx³  Σx⁴ ] [a2]   [ Σx²y]\n    \n    let a = [\n        [n, sum_x, sum_x2],\n        [sum_x, sum_x2, sum_x3],\n        [sum_x2, sum_x3, sum_x4]\n    ];\n    let b = [sum_y, sum_xy, sum_x2y];\n    \n    let coeffs = solve_3x3_system(a, b);\n    \n    (coeffs[0], coeffs[1], coeffs[2])\n}\n\nfn main() {\n    // Datos del ejemplo\n    let x_data = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];\n    let y_data = [1.3, 3.5, 4.2, 5.0, 7.0, 8.8, 10.1, 12.5, 13.0, 15.6];\n\n    let (a0, a1, a2) = quadratic_regression(&x_data, &y_data);\n\n    println!(\"Parábola de mejor ajuste: y = {:.4} + {:.4}x + {:.4}x²\", a0, a1, a2);\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Ajuste Exponencial",
        "url": "least-squares-exponential",
        "examples": [
          {
            "id": 1,
            "title": "Regresión Exponencial en Rust",
            "text": "Implementar el método de mínimos cuadrados para ajustar una curva exponencial y = a·bˣ a un conjunto de datos.<br><br>● Transformar los datos y a Y = ln(y)<br>● Aplicar regresión lineal a los datos transformados (X, Y)<br>● Calcular los parámetros originales a y b a partir de los coeficientes lineales",
            "code": "// Regresión Exponencial en Rust\n\nfn exponential_regression(x_vals: &[f64], y_vals: &[f64]) -> (f64, f64) {\n    // Transformar y a Y = ln(y)\n    let y_transformed: Vec<f64> = y_vals.iter()\n        .map(|&y| {\n            if y <= 0.0 {\n                panic!(\"Todos los valores de y deben ser positivos para aplicar ln(y).\");\n            }\n            y.ln()\n        })\n        .collect();\n    \n    // Aplicar regresión lineal a (x_vals, y_transformed)\n    let n = x_vals.len() as f64;\n    let sum_x = x_vals.iter().sum::<f64>();\n    let sum_y = y_transformed.iter().sum::<f64>();\n    let sum_xy: f64 = x_vals.iter().zip(y_transformed.iter()).map(|(x, y)| x * y).sum();\n    let sum_x2: f64 = x_vals.iter().map(|x| x * x).sum();\n\n    // Sistema de ecuaciones normales para la regresión lineal de Y = a0 + a1*X\n    let a11 = n;\n    let a12 = sum_x;\n    let a21 = sum_x;\n    let a22 = sum_x2;\n    let b1 = sum_y;\n    let b2 = sum_xy;\n    \n    // Resolver el sistema 2x2\n    let det_a = a11 * a22 - a12 * a21;\n    if det_a.abs() < 1e-10 {\n        panic!(\"El sistema no tiene solución única.\");\n    }\n    \n    let a0 = (b1 * a22 - b2 * a12) / det_a; // a0 = ln(a)\n    let a1 = (a11 * b2 - a21 * b1) / det_a; // a1 = ln(b)\n    \n    // Calcular los parámetros originales\n    let a = a0.exp(); // a = e^a0\n    let b = a1.exp(); // b = e^a1\n    \n    (a, b)\n}\n\nfn main() {\n    // Datos del ejemplo\n    let x_data = [2.0, 3.4, 5.2, 6.1, 6.7, 7.0];\n    let y_data = [22.103, 107.7352, 825.6741, 2285.7786, 4506.6225, 6327.9012];\n\n    let (a, b) = exponential_regression(&x_data, &y_data);\n\n    println!(\"Curva exponencial de mejor ajuste: y = {:.4} * ({:.4})^x\", a, b);\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de Newton-Raphson",
        "url": "newton-raphson-method",
        "examples": [
          {
            "id": 1,
            "title": "Implementación del Método de Newton-Raphson en Rust",
            "text": "Implementar el método de Newton-Raphson para encontrar la raíz de f(x) = x³ - x - 2.<br><br>● Definir la función y su derivada<br>● Implementar la fórmula iterativa<br>● Probar con diferentes valores iniciales",
            "code": "// Método de Newton-Raphson en Rust\n\n// Función objetivo: f(x) = x³ - x - 2\nfn funcion_objetivo(x: f64) -> f64 {\n    x * x * x - x - 2.0\n}\n\n// Derivada de la función: f'(x) = 3x² - 1\nfn derivada_funcion(x: f64) -> f64 {\n    3.0 * x * x - 1.0\n}\n\n// Método de Newton-Raphson\nfn newton_raphson<F, DF>(f: F, df: DF, mut x0: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n    DF: Fn(f64) -> f64,\n{\n    for iter in 0..max_iter {\n        let fx = f(x0);\n        let dfx = df(x0);\n        \n        // Evitar división por cero\n        if dfx.abs() < 1e-10 {\n            println!(\"Derivada demasiado pequeña, posible error.\");\n            return None;\n        }\n        \n        let x1 = x0 - fx / dfx;\n        \n        // Verificar convergencia\n        if (x1 - x0).abs() < tolerancia || fx.abs() < tolerancia {\n            return Some((x1, iter + 1));\n        }\n        \n        x0 = x1;\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n\nfn main() {\n    let x0 = 1.0; // Valor inicial\n    let tolerancia = 1e-6;\n    let max_iter = 100;\n    \n    println!(\"Buscando raíz de f(x) = x³ - x - 2 con x0 = {}\", x0);\n    println!(\"Tolerancia: {}\", tolerancia);\n    \n    match newton_raphson(funcion_objetivo, derivada_funcion, x0, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n    \n    // Prueba con otro valor inicial\n    println!(\"\\n=== Prueba con x0 = 2.0 ===\");\n    let x0_2 = 2.0;\n    match newton_raphson(funcion_objetivo, derivada_funcion, x0_2, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de la Secante",
        "url": "secant-method",
        "examples": [
          {
            "id": 1,
            "title": "Implementación del Método de la Secante en Rust",
            "text": "Implementar el método de la secante para encontrar la raíz de f(x) = x³ - x - 2.<br><br>● Definir la función objetivo<br>● Implementar la fórmula iterativa de la secante<br>● Probar con diferentes pares de valores iniciales",
            "code": "// Método de la Secante en Rust\n\n// Función objetivo: f(x) = x³ - x - 2\nfn funcion_objetivo(x: f64) -> f64 {\n    x * x * x - x - 2.0\n}\n\n// Método de la Secante\nfn secante<F>(f: F, mut x0: f64, mut x1: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut fx0 = f(x0);\n    let mut fx1 = f(x1);\n    \n    for iter in 0..max_iter {\n        // Evitar división por cero\n        if (fx1 - fx0).abs() < 1e-10 {\n            println!(\"Diferencia de funciones demasiado pequeña, posible error.\");\n            return None;\n        }\n        \n        let x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0);\n        let fx2 = f(x2);\n        \n        // Verificar convergencia\n        if (x2 - x1).abs() < tolerancia || fx2.abs() < tolerancia {\n            return Some((x2, iter + 1));\n        }\n        \n        // Actualizar valores\n        x0 = x1;\n        fx0 = fx1;\n        x1 = x2;\n        fx1 = fx2;\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n\nfn main() {\n    let x0 = 1.0; // Primer valor inicial\n    let x1 = 2.0; // Segundo valor inicial\n    let tolerancia = 1e-6;\n    let max_iter = 100;\n    \n    println!(\"Buscando raíz de f(x) = x³ - x - 2 con x0 = {}, x1 = {}\", x0, x1);\n    println!(\"Tolerancia: {}\", tolerancia);\n    \n    match secante(funcion_objetivo, x0, x1, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n    \n    // Prueba con otro par de valores iniciales\n    println!(\"\\n=== Prueba con x0 = 0.5, x1 = 1.5 ===\");\n    let x0_2 = 0.5;\n    let x1_2 = 1.5;\n    match secante(funcion_objetivo, x0_2, x1_2, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de la Falsa Posición",
        "url": "false-position-method",
        "examples": [
          {
            "id": 1,
            "title": "Implementación del Método de la Falsa Posición en Rust",
            "text": "Implementar el método de la falsa posición para encontrar la raíz de f(x) = x³ - x - 2 en el intervalo [1, 2].<br><br>● Definir la función objetivo<br>● Implementar el algoritmo de falsa posición<br>● Comparar con el método de bisección",
            "code": "// Método de la Falsa Posición en Rust\n\n// Función objetivo: f(x) = x³ - x - 2\nfn funcion_objetivo(x: f64) -> f64 {\n    x * x * x - x - 2.0\n}\n\n// Método de la Falsa Posición (Regula Falsi)\nfn falsa_posicion<F>(f: F, mut a: f64, mut b: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut fa = f(a);\n    let mut fb = f(b);\n    \n    // Verificar condición de Bolzano\n    if fa * fb >= 0.0 {\n        println!(\"No se cumple la condición f(a) × f(b) < 0\");\n        return None;\n    }\n    \n    for iter in 0..max_iter {\n        // Calcular el punto de falsa posición\n        let c = (a * fb - b * fa) / (fb - fa);\n        let fc = f(c);\n        \n        // Verificar convergencia\n        if fc.abs() < tolerancia || (b - a).abs() < tolerancia {\n            return Some((c, iter + 1));\n        }\n        \n        // Actualizar intervalo\n        if fa * fc < 0.0 {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n\nfn main() {\n    let a = 1.0;\n    let b = 2.0;\n    let tolerancia = 1e-6;\n    let max_iter = 100;\n    \n    println!(\"Buscando raíz de f(x) = x³ - x - 2 en [{}, {}]\", a, b);\n    println!(\"Tolerancia: {}\", tolerancia);\n    \n    match falsa_posicion(funcion_objetivo, a, b, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n    \n    // Comparación con el método de bisección\n    println!(\"\\n=== Comparación con el método de Bisección ===\");\n    match biseccion(funcion_objetivo, a, b, tolerancia, max_iter) {\n        Some((raiz_bis, iter_bis)) => {\n            println!(\"Bisección: Raíz = {:.8}, Iteraciones = {}\", raiz_bis, iter_bis);\n        },\n        None => println!(\"Bisección: No se pudo encontrar la raíz\"),\n    }\n}\n\n// Función auxiliar para el método de bisección (copiada desde el ejemplo anterior)\nfn biseccion<F>(f: F, mut a: f64, mut b: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut fa = f(a);\n    let mut fb = f(b);\n    \n    if fa * fb >= 0.0 {\n        println!(\"No se cumple la condición f(a) × f(b) < 0\");\n        return None;\n    }\n    \n    for iter in 0..max_iter {\n        let c = (a + b) / 2.0;\n        let fc = f(c);\n        \n        if fc.abs() < tolerancia || (b - a) / 2.0 < tolerancia {\n            return Some((c, iter + 1));\n        }\n        \n        if fa * fc < 0.0 {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      }
    ]
  },
  {
    "name": "ADA I",
    "url": "ada-i",
    "syllabus": [
      {
        "name": "Introducción al Análisis de Algoritmos",
        "url": "algorithm-analysis",
        "examples": [
          {
            "id": 1,
            "title": "Algoritmo de Euclides para MCD",
            "text": "Considere un algoritmo iterativo para calcular el máximo común divisor de dos números m,n:<br><br>● <strong>Defina sus entradas, salidas y proceso (pseudocódigo)</strong><br>● <strong>Es posible determinar mejor caso, peor caso y caso promedio ?</strong>",
            "code": "// Algoritmo de Euclides para MCD\nfn gcd(mut a: u32, mut b: u32) -> u32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\n// Ejemplo de uso\nfn main() {\n    let result = gcd(48, 18);\n    println!(\"GCD(48, 18) = {}\", result); // Salida: GCD(48, 18) = 6\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Orden de Crecimiento",
        "url": "growth-order",
        "examples": [
          {
            "id": 2,
            "title": "Comparación de Algoritmos",
            "text": "Supongamos que tenemos 4 algoritmos para resolver un mismo problema, los tiempos de ejecución de esos algoritmos son los siguientes:<br><br><ul><li><strong>A<sub>1</sub></strong> con T(n) = 200n</li><li><strong>A<sub>2</sub></strong> con T(n) = 6n<sup>2</sup></li><li><strong>A<sub>3</sub></strong> con T(n) = 3n<sup>3</sup>/2</li><li><strong>A<sub>4</sub></strong> con T(n) = 4log<sub>3</sub>n</li></ul><br>Teniendo en cuenta el orden de crecimiento de la función de tiempo de ejecución determinar la eficiencia de cada algoritmo.<br><br>Si dispone de 500 segundos para ejecutar cada algoritmo ¿Cuál es el tamaño máximo de la entrada que puede procesar cada uno? teniendo en cuenta una máquina que puede ejecutar 100 ins/segundo",
            "code": "// Análisis de complejidad y cálculo del tamaño máximo de entrada\nfunction calculateMaxInputSize() {\n  const timeAvailable = 500; // segundos\n  const instructionsPerSecond = 100;\n  const maxInstructions = timeAvailable * instructionsPerSecond;\n  \n  console.log(`Máximo número de instrucciones: ${maxInstructions}`);\n  \n  // A1: T(n) = 200n\n  const nA1 = Math.floor(maxInstructions / 200);\n  console.log(`Tamaño máximo para A₁: ${nA1}`);\n  \n  // A2: T(n) = 6n²\n  const nA2 = Math.floor(Math.sqrt(maxInstructions / 6));\n  console.log(`Tamaño máximo para A₂: ${nA2}`);\n  \n  // A3: T(n) = 3n³/2\n  const nA3 = Math.floor(Math.cbrt((2 * maxInstructions) / 3));\n  console.log(`Tamaño máximo para A₃: ${nA3}`);\n  \n  // A4: T(n) = 4log₃(n)\n  // Resolviendo: 4 * log₃(n) ≤ maxInstructions\n  // log₃(n) ≤ maxInstructions / 4\n  // n ≤ 3^(maxInstructions / 4)\n  const nA4 = Math.floor(Math.pow(3, maxInstructions / 4));\n  console.log(`Tamaño máximo para A₄: ${nA4}`);\n}\n\ncalculateMaxInputSize();",
            "language": "rust",
            "showSolutionButton": false
          },
          {
            "id": 3,
            "title": "Caja fuerte con giros",
            "text": "Tus ahorros de toda la vida han quedado atrapados en una caja fuerte y has olvidado la combinación. La caja tiene una rueda con los números del 1 al 5 en orden inicial <strong>1 2 3 4 5</strong>. Puedes girar la rueda hacia la <strong>izquierda</strong> o hacia la <strong>derecha</strong> una cantidad de veces.<br><br>Si giras una posición hacia la izquierda, el orden será <strong>2 3 4 5 1</strong>. Si giras una posición hacia la derecha, el orden será <strong>5 1 2 3 4</strong>.<br><br>Escribe un programa que, dadas la cantidad de rotaciones hacia la izquierda y hacia la derecha, determine el orden final de los números.<br><br><strong>Ejemplo:</strong><br>Entrada → (1,0) → Salida → 2 3 4 5 1<br>Entrada → (2,0) → Salida → 3 4 5 1 2",
            "code": "// Programa en Rust: Caja fuerte con giros\nfn rotate_safe(left: i32, right: i32) -> Vec<i32> {\n    let mut nums = vec![1, 2, 3, 4, 5];\n    let len = nums.len() as i32;\n\n    // Efecto neto de los movimientos (izquierda positivo, derecha negativo)\n    let net_moves = (left - right).rem_euclid(len);\n\n    // Rotamos según el net_moves\n    nums.rotate_left(net_moves as usize);\n    nums\n}\n\nfn main() {\n    let result1 = rotate_safe(1, 0);\n    println!(\"Entrada (1,0) -> Salida -> {:?}\", result1);\n\n    let result2 = rotate_safe(2, 0);\n    println!(\"Entrada (2,0) -> Salida -> {:?}\", result2);\n\n    let result3 = rotate_safe(0, 1);\n    println!(\"Entrada (0,1) -> Salida -> {:?}\", result3);\n\n    let result4 = rotate_safe(3, 1);\n    println!(\"Entrada (3,1) -> Salida -> {:?}\", result4);\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Notación Asintótica",
        "url": "asymptotic-notation",
        "examples": []
      }
    ]
  },
  {
    "name": "Programación Imperativa",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Programación Orientada a Objetos",
    "url": "objects-programming",
    "syllabus": [
      {
        "name": ""
      }
    ]
  },
  {
    "name": "Programación Concurrente",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Álgebra Lineal",
    "url": "linear-algebra",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Física I",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Cálculo Monovariable",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Cálculo Multivariable",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Probabilidad y Estadística",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Ingeniería Económica",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Bases de Datos",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Matemáticas Discretas I",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Matemáticas Discretas II",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  }
]
