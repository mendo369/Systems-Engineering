[
  {
    "name": "Sistemas Operativos",
    "url": "operating-systems",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Simulación y Computación Numérica",
    "url": "simulation-numerical-computing",
    "syllabus": [
      {
        "name": "Teorema de Bolzano",
        "url": "bolzano-theorem",
        "examples": [
          {
            "id": 1,
            "title": "Verificación del Teorema de Bolzano en Rust",
            "text": "Implementar una función que verifique el Teorema de Bolzano para diferentes funciones y intervalos.<br><br>● Verificar la continuidad y cambio de signo<br>● Encontrar intervalos donde se cumple el teorema<br>● Visualizar gráficamente los resultados",
            "code": "// Teorema de Bolzano en Rust\n\n// Funciones de prueba\nfn funcion_1(x: f64) -> f64 {\n    x * x - 2.0  // f(x) = x² - 2\n}\n\nfn funcion_2(x: f64) -> f64 {\n    x * x * x - x - 2.0  // f(x) = x³ - x - 2\n}\n\nfn funcion_3(x: f64) -> f64 {\n    f64::sin(x) - x / 2.0  // f(x) = sin(x) - x/2\n}\n\nfn funcion_4(x: f64) -> f64 {\n    f64::exp(x) - 3.0 * x  // f(x) = e^x - 3x\n}\n\n// Verificar Teorema de Bolzano\nfn verificar_bolzano<F>(f: F, a: f64, b: f64) -> bool\nwhere\n    F: Fn(f64) -> f64,\n{\n    let fa = f(a);\n    let fb = f(b);\n    \n    // Teorema de Bolzano: f(a) × f(b) < 0\n    fa * fb < 0.0\n}\n\n// Buscar intervalo donde se cumple Bolzano (método de exploración)\nfn buscar_intervalo_bolzano<F>(f: F, inicio: f64, fin: f64, paso: f64) -> Option<(f64, f64)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut x = inicio;\n    \n    while x < fin {\n        let a = x;\n        let b = x + paso;\n        \n        if verificar_bolzano(&f, a, b) {\n            return Some((a, b));\n        }\n        \n        x += paso;\n    }\n    \n    None\n}\n\n// Verificar continuidad numérica (simple check)\nfn es_continua<F>(f: F, a: f64, b: f64, num_puntos: usize) -> bool\nwhere\n    F: Fn(f64) -> f64,\n{\n    let paso = (b - a) / (num_puntos as f64);\n    let mut x = a;\n    \n    // Verificar que no hay discontinuidades obvias (valores infinitos o NaN)\n    for _ in 0..num_puntos {\n        let valor = f(x);\n        if valor.is_infinite() || valor.is_nan() {\n            return false;\n        }\n        x += paso;\n    }\n    \n    true\n}\n\nfn main() {\n    println!(\"=== Verificación del Teorema de Bolzano ===\\n\");\n    \n    // Prueba 1: f(x) = x² - 2 en [1, 2]\n    let a1 = 1.0;\n    let b1 = 2.0;\n    let continua1 = es_continua(funcion_1, a1, b1, 100);\n    let bolzano1 = verificar_bolzano(funcion_1, a1, b1);\n    \n    println!(\"Función 1: f(x) = x² - 2\");\n    println!(\"Intervalo: [{}, {}]\", a1, b1);\n    println!(\"f({}) = {:.4}\", a1, funcion_1(a1));\n    println!(\"f({}) = {:.4}\", b1, funcion_1(b1));\n    println!(\"Continua: {}\", continua1);\n    println!(\"Cumple Bolzano: {}\", bolzano1);\n    println!(\"Teorema aplicable: {}\", continua1 && bolzano1);\n    \n    if continua1 && bolzano1 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a1, b1);\n    }\n    println!();\n    \n    // Prueba 2: f(x) = x³ - x - 2\n    let a2 = 1.0;\n    let b2 = 2.0;\n    let continua2 = es_continua(funcion_2, a2, b2, 100);\n    let bolzano2 = verificar_bolzano(funcion_2, a2, b2);\n    \n    println!(\"Función 2: f(x) = x³ - x - 2\");\n    println!(\"Intervalo: [{}, {}]\", a2, b2);\n    println!(\"f({}) = {:.4}\", a2, funcion_2(a2));\n    println!(\"f({}) = {:.4}\", b2, funcion_2(b2));\n    println!(\"Continua: {}\", continua2);\n    println!(\"Cumple Bolzano: {}\", bolzano2);\n    println!(\"Teorema aplicable: {}\", continua2 && bolzano2);\n    \n    if continua2 && bolzano2 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a2, b2);\n    }\n    println!();\n    \n    // Prueba 3: f(x) = sin(x) - x/2\n    let a3 = 1.0;\n    let b3 = 3.0;\n    let continua3 = es_continua(funcion_3, a3, b3, 100);\n    let bolzano3 = verificar_bolzano(funcion_3, a3, b3);\n    \n    println!(\"Función 3: f(x) = sin(x) - x/2\");\n    println!(\"Intervalo: [{}, {}]\", a3, b3);\n    println!(\"f({}) = {:.4}\", a3, funcion_3(a3));\n    println!(\"f({}) = {:.4}\", b3, funcion_3(b3));\n    println!(\"Continua: {}\", continua3);\n    println!(\"Cumple Bolzano: {}\", bolzano3);\n    println!(\"Teorema aplicable: {}\", continua3 && bolzano3);\n    \n    if continua3 && bolzano3 {\n        println!(\"→ Existe al menos una raíz en ({}, {})\", a3, b3);\n    }\n    println!();\n    \n    // Prueba 4: Buscar intervalo automáticamente\n    println!(\"=== Búsqueda Automática de Intervalos ===\");\n    \n    match buscar_intervalo_bolzano(funcion_1, -5.0, 5.0, 0.5) {\n        Some((a, b)) => {\n            println!(\"Función 1: Intervalo encontrado [{}, {}]\", a, b);\n            println!(\"f({}) = {:.4}, f({}) = {:.4}\", a, funcion_1(a), b, funcion_1(b));\n        },\n        None => println!(\"Función 1: No se encontró intervalo con Bolzano en [-5, 5]\"),\n    }\n    \n    match buscar_intervalo_bolzano(funcion_4, -2.0, 2.0, 0.5) {\n        Some((a, b)) => {\n            println!(\"Función 4: Intervalo encontrado [{}, {}]\", a, b);\n            println!(\"f({}) = {:.4}, f({}) = {:.4}\", a, funcion_4(a), b, funcion_4(b));\n        },\n        None => println!(\"Función 4: No se encontró intervalo con Bolzano en [-2, 2]\"),\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de Bisección",
        "url": "bisection-method",
        "examples": [
          {
            "id": 1,
            "title": "Implementación del Método de Bisección en Rust",
            "text": "Implementar el método de bisección para encontrar la raíz de f(x) = x² - 2 en el intervalo [1, 2].<br><br>● Definir la función objetivo<br>● Implementar el algoritmo de bisección<br>● Probar con diferentes tolerancias",
            "code": "// Método de Bisección en Rust\n\n// Función objetivo: f(x) = x² - 2\nfn funcion_objetivo(x: f64) -> f64 {\n    x * x - 2.0\n}\n\n// Método de bisección\nfn biseccion<F>(f: F, mut a: f64, mut b: f64, tolerancia: f64, max_iter: usize) -> Option<(f64, usize)>\nwhere\n    F: Fn(f64) -> f64,\n{\n    let mut fa = f(a);\n    let mut fb = f(b);\n    \n    // Verificar condición de Bolzano\n    if fa * fb >= 0.0 {\n        println!(\"No se cumple la condición f(a) × f(b) < 0\");\n        return None;\n    }\n    \n    for iter in 0..max_iter {\n        let c = (a + b) / 2.0;\n        let fc = f(c);\n        \n        // Verificar convergencia\n        if fc.abs() < tolerancia || (b - a) / 2.0 < tolerancia {\n            return Some((c, iter + 1));\n        }\n        \n        // Actualizar intervalo\n        if fa * fc < 0.0 {\n            b = c;\n            fb = fc;\n        } else {\n            a = c;\n            fa = fc;\n        }\n    }\n    \n    println!(\"No se alcanzó convergencia en {} iteraciones\", max_iter);\n    None\n}\n\nfn main() {\n    let a = 1.0;\n    let b = 2.0;\n    let tolerancia = 1e-6;\n    let max_iter = 100;\n    \n    println!(\"Buscando raíz de f(x) = x² - 2 en [{}, {}]\", a, b);\n    println!(\"Tolerancia: {}\", tolerancia);\n    \n    match biseccion(funcion_objetivo, a, b, tolerancia, max_iter) {\n        Some((raiz, iteraciones)) => {\n            println!(\"Raíz encontrada: {:.8}\", raiz);\n            println!(\"Iteraciones: {}\", iteraciones);\n            println!(\"Verificación: f({:.8}) = {:.8}\", raiz, funcion_objetivo(raiz));\n        },\n        None => println!(\"No se pudo encontrar la raíz\"),\n    }\n    \n    // Prueba con diferentes tolerancias\n    println!(\"\\n=== Pruebas con diferentes tolerancias ===\");\n    let tolerancias = [1e-3, 1e-6, 1e-9, 1e-12];\n    \n    for &tol in &tolerancias {\n        if let Some((raiz, iter)) = biseccion(funcion_objetivo, a, b, tol, max_iter) {\n            println!(\"Tol: {:.0e} → Raíz: {:.10} ({} iter)\", tol, raiz, iter);\n        }\n    }\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Interpolación",
        "url": "interpolation",
        "examples": [
          {
            "id": 1,
            "title": "Interpolación de Lagrange en Rust",
            "text": "Implementar el polinomio de interpolación de Lagrange para un conjunto de puntos dados.<br><br>● Calcular los polinomios base L_i(x)<br>● Evaluar el polinomio interpolador P(x)<br>● Comparar con el valor real de la función original",
            "code": "// Interpolación de Lagrange en Rust\n\n// Función para calcular el polinomio de Lagrange\nfn lagrange_interpolation(x_points: &[f64], y_points: &[f64], x: f64) -> f64 {\n    let n = x_points.len();\n    let mut result = 0.0;\n\n    for i in 0..n {\n        let mut term = y_points[i];\n        for j in 0..n {\n            if i != j {\n                term *= (x - x_points[j]) / (x_points[i] - x_points[j]);\n            }\n        }\n        result += term;\n    }\n\n    result\n}\n\nfn main() {\n    // Puntos conocidos\n    let x_known = [1.0, 2.0, 3.0];\n    let y_known = [1.0, 4.0, 9.0]; // f(x) = x^2\n\n    let x_to_eval = 2.5;\n    let result = lagrange_interpolation(&x_known, &y_known, x_to_eval);\n    let actual = x_to_eval.powi(2);\n\n    println!(\"P({}) = {}\", x_to_eval, result);\n    println!(\"f({}) = {}\", x_to_eval, actual);\n    println!(\"Error de interpolación = {}\", (result - actual).abs());\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Aproximación por Mínimos Cuadrados",
        "url": "least-squares",
        "examples": [
          {
            "id": 1,
            "title": "Regresión Lineal Simple en Rust",
            "text": "Calcular la recta de mínimos cuadrados para un conjunto de datos bivariados.<br><br>● Calcular pendiente (m) e intercepto (b)<br>● Calcular el coeficiente de correlación (r)",
            "code": "// Regresión Lineal Simple en Rust\n\n// Función para calcular la regresión lineal\nfn linear_regression(x_vals: &[f64], y_vals: &[f64]) -> (f64, f64, f64) {\n    let n = x_vals.len() as f64;\n    let sum_x = x_vals.iter().sum::<f64>();\n    let sum_y = y_vals.iter().sum::<f64>();\n    let sum_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| x * y).sum();\n    let sum_x2: f64 = x_vals.iter().map(|x| x * x).sum();\n\n    let mean_x = sum_x / n;\n    let mean_y = sum_y / n;\n\n    let slope = (n * sum_xy - sum_x * sum_y) / (n * sum_x2 - sum_x * sum_x);\n    let intercept = mean_y - slope * mean_x;\n\n    // Coeficiente de correlación\n    let ss_xy: f64 = x_vals.iter().zip(y_vals.iter()).map(|(x, y)| (x - mean_x) * (y - mean_y)).sum();\n    let ss_xx: f64 = x_vals.iter().map(|x| (x - mean_x).powi(2)).sum();\n    let ss_yy: f64 = y_vals.iter().map(|y| (y - mean_y).powi(2)).sum();\n    let correlation = ss_xy / (ss_xx * ss_yy).sqrt();\n\n    (slope, intercept, correlation)\n}\n\nfn main() {\n    let x_data = [1.0, 2.0, 3.0, 4.0, 5.0];\n    let y_data = [2.1, 3.9, 6.1, 7.9, 10.0];\n\n    let (slope, intercept, correlation) = linear_regression(&x_data, &y_data);\n\n    println!(\"Recta de regresión: y = {:.4}x + {:.4}\", slope, intercept);\n    println!(\"Coeficiente de correlación (r): {:.4}\", correlation);\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Sistemas de Ecuaciones Lineales y No Lineales",
        "url": "system-of-equations",
        "examples": [
          {
            "id": 1,
            "title": "Método de Jacobi en Rust",
            "text": "Implementar el método iterativo de Jacobi para resolver un sistema de ecuaciones lineales Ax = b.<br><br>● Verificar convergencia (diagonal dominante)<br>● Iterar hasta cumplir criterio de parada",
            "code": "// Método de Jacobi en Rust\n\n// Función para calcular la norma infinito de un vector\nfn norm_inf(v: &[f64]) -> f64 {\n    v.iter().map(|x| x.abs()).fold(0.0, |a, b| a.max(b))\n}\n\n// Función para clonar un vector\nfn clone_vec(v: &[f64]) -> Vec<f64> {\n    v.iter().cloned().collect()\n}\n\n// Método de Jacobi\nfn jacobi_method(\n    a: &Vec<Vec<f64>>,\n    b: &[f64],\n    mut x: Vec<f64>,\n    tolerance: f64,\n    max_iterations: usize,\n) -> Option<Vec<f64>> {\n    let n = b.len();\n    let mut x_new = vec![0.0; n];\n\n    for iteration in 0..max_iterations {\n        for i in 0..n {\n            let mut sum = 0.0;\n            for j in 0..n {\n                if i != j {\n                    sum += a[i][j] * x[j];\n                }\n            }\n            x_new[i] = (b[i] - sum) / a[i][i];\n        }\n\n        // Criterio de parada\n        let diff: Vec<f64> = x_new.iter().zip(x.iter()).map(|(a, b)| a - b).collect();\n        if norm_inf(&diff) < tolerance {\n            println!(\"Convergió en {} iteraciones.\", iteration + 1);\n            return Some(x_new);\n        }\n\n        x = clone_vec(&x_new);\n    }\n\n    println!(\"No se alcanzó la convergencia en {} iteraciones.\", max_iterations);\n    None\n}\n\nfn main() {\n    // Ejemplo de sistema\n    let a = vec!\n    [\n        vec![4.0, -1.0, 0.0],\n        vec![-1.0, 4.0, -1.0],\n        vec![0.0, -1.0, 4.0],\n    ];\n    let b = [12.0, 12.0, 12.0];\n    let x_initial = vec![0.0, 0.0, 0.0];\n    let tolerance = 1e-3;\n    let max_iter = 100;\n\n    match jacobi_method(&a, &b, x_initial, tolerance, max_iter) {\n        Some(solution) => println!(\"Solución x: {:?}\", solution),\n        None => println!(\"No se pudo resolver el sistema.\"),\n    }\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Método de Diferencias Finitas (MDF) para PVF",
        "url": "finite-difference-method",
        "examples": [
          {
            "id": 1,
            "title": "MDF para EDO de Segundo Orden en Rust",
            "text": "Resolver un problema de valor de frontera (PVF) para una EDO lineal de segundo orden usando el Método de Diferencias Finitas.<br><br>● Discretizar el dominio<br>● Aproximar derivadas<br>● Resolver el sistema lineal resultante",
            "code": "// MDF para EDO de Segundo Orden en Rust\n// Nota: Este ejemplo simplifica la resolución del sistema tridiagonal\n// En la práctica, se usaría una librería como nalgebra o implementar un solver específico.\n\n// Definir funciones p(x), q(x), r(x) para el ejemplo y'' = -2/x y' + 2/x^2 y + sin(ln x)/x^2\nfn p(x: f64) -> f64 {\n    -2.0 / x\n}\n\nfn q(x: f64) -> f64 {\n    2.0 / (x * x)\n}\n\nfn r(x: f64) -> f64 {\n    f64::sin(f64::ln(x)) / (x * x)\n}\n\nfn solve_bvp_mdf(\n    p_fn: fn(f64) -> f64,\n    q_fn: fn(f64) -> f64,\n    r_fn: fn(f64) -> f64,\n    a: f64,\n    b: f64,\n    alpha: f64,\n    beta: f64,\n    n_nodes: usize,\n) -> (Vec<f64>, Vec<f64>) {\n    let h = (b - a) / ((n_nodes + 1) as f64);\n    let mut x = vec![0.0; n_nodes + 2];\n    for i in 0..n_nodes + 2 {\n        x[i] = a + (i as f64) * h;\n    }\n\n    // Inicializar matrices del sistema tridiagonal A y vector b\n    let n_int = n_nodes; // Número de nodos interiores\n    let mut a_mat = vec![vec![0.0; n_int]; n_int];\n    let mut b_rhs = vec![0.0; n_int];\n\n    for i in 0..n_int {\n        let idx = i + 1; // Índice del nodo interior en x[]\n        let xi = x[idx];\n\n        let p_val = p_fn(xi);\n        let q_val = q_fn(xi);\n        let r_val = r_fn(xi);\n\n        let a_coeff = (1.0 / (h * h)) - (p_val / (2.0 * h));\n        let b_coeff = q_val - (2.0 / (h * h));\n        let c_coeff = (1.0 / (h * h)) + (p_val / (2.0 * h));\n\n        a_mat[i][i] = b_coeff;\n        if i > 0 {\n            a_mat[i][i - 1] = a_coeff;\n        }\n        if i < n_int - 1 {\n            a_mat[i][i + 1] = c_coeff;\n        }\n\n        b_rhs[i] = r_val;\n\n        // Aplicar condiciones de frontera\n        if i == 0 {\n            b_rhs[i] -= a_coeff * alpha;\n        }\n        if i == n_int - 1 {\n            b_rhs[i] -= c_coeff * beta;\n        }\n    }\n\n    // Resolver el sistema A * y_interior = b_rhs\n    // Aquí usamos una función ficticia `solve_tridiag` para representar la resolución.\n    // En la práctica, usarías nalgebra::linalg::TridiagonalMatrix o una implementación propia.\n    // let y_interior = solve_tridiag(&a_mat, &b_rhs);\n    // Por simplicidad, devolvemos solo los nodos y placeholders para la solución\n    //println!(\"Matriz A: {:?}\", a_mat);\n    //println!(\"Vector b: {:?}\", b_rhs);\n    println!(\"Sistema tridiagonal generado para {} nodos interiores.\", n_int);\n    println!(\"En una implementación completa, se resolvería: A * y_interior = b_rhs\");\n    \n    let y_solution = vec![0.0; n_nodes + 2]; // Placeholder\n    (x, y_solution)\n}\n\nfn main() {\n    let a = 1.0;\n    let b = 2.0;\n    let alpha = 1.0;\n    let beta = 2.0;\n    let n = 10; // Número de nodos interiores\n\n    let (x, y) = solve_bvp_mdf(p, q, r, a, b, alpha, beta, n);\n\n    println!(\"Nodos x: {:?}\", x);\n    println!(\"Solución y (placeholder): {:?}\", y);\n    // Para visualización, se usaría una crate como plotters o se exportaría a un CSV.\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      }
    ]
  },
  {
    "name": "ADA I",
    "url": "ada-i",
    "syllabus": [
      {
        "name": "Introducción al Análisis de Algoritmos",
        "url": "algorithm-analysis",
        "examples": [
          {
            "id": 1,
            "title": "Algoritmo de Euclides para MCD",
            "text": "Considere un algoritmo iterativo para calcular el máximo común divisor de dos números m,n:<br><br>● <strong>Defina sus entradas, salidas y proceso (pseudocódigo)</strong><br>● <strong>Es posible determinar mejor caso, peor caso y caso promedio ?</strong>",
            "code": "// Algoritmo de Euclides para MCD\nfn gcd(mut a: u32, mut b: u32) -> u32 {\n    while b != 0 {\n        let temp = b;\n        b = a % b;\n        a = temp;\n    }\n    a\n}\n\n// Ejemplo de uso\nfn main() {\n    let result = gcd(48, 18);\n    println!(\"GCD(48, 18) = {}\", result); // Salida: GCD(48, 18) = 6\n}",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Orden de Crecimiento",
        "url": "growth-order",
        "examples": [
          {
            "id": 2,
            "title": "Comparación de Algoritmos",
            "text": "Supongamos que tenemos 4 algoritmos para resolver un mismo problema, los tiempos de ejecución de esos algoritmos son los siguientes:<br><br><ul><li><strong>A<sub>1</sub></strong> con T(n) = 200n</li><li><strong>A<sub>2</sub></strong> con T(n) = 6n<sup>2</sup></li><li><strong>A<sub>3</sub></strong> con T(n) = 3n<sup>3</sup>/2</li><li><strong>A<sub>4</sub></strong> con T(n) = 4log<sub>3</sub>n</li></ul><br>Teniendo en cuenta el orden de crecimiento de la función de tiempo de ejecución determinar la eficiencia de cada algoritmo.<br><br>Si dispone de 500 segundos para ejecutar cada algoritmo ¿Cuál es el tamaño máximo de la entrada que puede procesar cada uno? teniendo en cuenta una máquina que puede ejecutar 100 ins/segundo",
            "code": "// Análisis de complejidad y cálculo del tamaño máximo de entrada\nfunction calculateMaxInputSize() {\n  const timeAvailable = 500; // segundos\n  const instructionsPerSecond = 100;\n  const maxInstructions = timeAvailable * instructionsPerSecond;\n  \n  console.log(`Máximo número de instrucciones: ${maxInstructions}`);\n  \n  // A1: T(n) = 200n\n  const nA1 = Math.floor(maxInstructions / 200);\n  console.log(`Tamaño máximo para A₁: ${nA1}`);\n  \n  // A2: T(n) = 6n²\n  const nA2 = Math.floor(Math.sqrt(maxInstructions / 6));\n  console.log(`Tamaño máximo para A₂: ${nA2}`);\n  \n  // A3: T(n) = 3n³/2\n  const nA3 = Math.floor(Math.cbrt((2 * maxInstructions) / 3));\n  console.log(`Tamaño máximo para A₃: ${nA3}`);\n  \n  // A4: T(n) = 4log₃(n)\n  // Resolviendo: 4 * log₃(n) ≤ maxInstructions\n  // log₃(n) ≤ maxInstructions / 4\n  // n ≤ 3^(maxInstructions / 4)\n  const nA4 = Math.floor(Math.pow(3, maxInstructions / 4));\n  console.log(`Tamaño máximo para A₄: ${nA4}`);\n}\n\ncalculateMaxInputSize();",
            "language": "rust",
            "showSolutionButton": false
          },
          {
            "id": 3,
            "title": "Caja fuerte con giros",
            "text": "Tus ahorros de toda la vida han quedado atrapados en una caja fuerte y has olvidado la combinación. La caja tiene una rueda con los números del 1 al 5 en orden inicial <strong>1 2 3 4 5</strong>. Puedes girar la rueda hacia la <strong>izquierda</strong> o hacia la <strong>derecha</strong> una cantidad de veces.<br><br>Si giras una posición hacia la izquierda, el orden será <strong>2 3 4 5 1</strong>. Si giras una posición hacia la derecha, el orden será <strong>5 1 2 3 4</strong>.<br><br>Escribe un programa que, dadas la cantidad de rotaciones hacia la izquierda y hacia la derecha, determine el orden final de los números.<br><br><strong>Ejemplo:</strong><br>Entrada → (1,0) → Salida → 2 3 4 5 1<br>Entrada → (2,0) → Salida → 3 4 5 1 2",
            "code": "// Programa en Rust: Caja fuerte con giros\nfn rotate_safe(left: i32, right: i32) -> Vec<i32> {\n    let mut nums = vec![1, 2, 3, 4, 5];\n    let len = nums.len() as i32;\n\n    // Efecto neto de los movimientos (izquierda positivo, derecha negativo)\n    let net_moves = (left - right).rem_euclid(len);\n\n    // Rotamos según el net_moves\n    nums.rotate_left(net_moves as usize);\n    nums\n}\n\nfn main() {\n    let result1 = rotate_safe(1, 0);\n    println!(\"Entrada (1,0) -> Salida -> {:?}\", result1);\n\n    let result2 = rotate_safe(2, 0);\n    println!(\"Entrada (2,0) -> Salida -> {:?}\", result2);\n\n    let result3 = rotate_safe(0, 1);\n    println!(\"Entrada (0,1) -> Salida -> {:?}\", result3);\n\n    let result4 = rotate_safe(3, 1);\n    println!(\"Entrada (3,1) -> Salida -> {:?}\", result4);\n}\n",
            "language": "rust",
            "showSolutionButton": true
          }
        ]
      },
      {
        "name": "Notación Asintótica",
        "url": "asymptotic-notation",
        "examples": []
      }
    ]
  },
  {
    "name": "Programación Imperativa",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Programación Orientada a Objetos",
    "url": "objects-programming",
    "syllabus": [
      {
        "name": ""
      }
    ]
  },
  {
    "name": "Programación Concurrente",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Álgebra Lineal",
    "url": "linear-algebra",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Física I",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Cálculo Monovariable",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Cálculo Multivariable",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Probabilidad y Estadística",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Ingeniería Económica",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Bases de Datos",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Matemáticas Discretas I",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  },
  {
    "name": "Matemáticas Discretas II",
    "url": "test",
    "syllabus": [
      {
        "name": "",
        "url": ""
      }
    ]
  }
]
